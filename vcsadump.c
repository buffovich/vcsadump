/*
 * vcsadump - Linux virtual console color snapshot tool
 *
 * (C) 2003 Florian <petafrog@yahoo.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 59
 * Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */                                                                                

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

#define VCSANAME "/dev/vcsa"
#define PROGNAME "vcsadump"
#define CSSNAME "vcattrib.css"
#define HTMLNAME "vcdump.html"

typedef struct { 
  unsigned char ys, xs, cx, cy;
} VCHeader;

typedef struct { 
  unsigned char ch,attr;
} CA;

typedef struct {
  VCHeader h;
  CA *ca;
} VCDump;

/**
 * Dumps usage information to stderr and exits.
 */
void usage(void) 
{
  fprintf(stderr, "Usage: %s [-h | -e | -p | -C] [-v N] [-o fn] [-c fn]\n\n"
	  "Use exactly one of the following:\n"
	  "-h\twrite HTML page with inline attributes\n"
	  "-e\twrite HTML page with link to external CSS\n"
	  "-p\twrite HTML fragment containing screen dump only\n"
	  "-C\twrite external CSS containing all possible attributes (no VC dump made)\n"
	  "\n"
	  "Use zero or more of the following:\n"
	  "-v N\tuse virtual console N (default current VC)\n"
	  "-o fn\tset HTML filename (default \"%s\")\n"
	  "-c fn\tset external CSS filename (default \"%s\")\n"
	  "\n"
	  "Using \"-\" as a filename causes output to be written to stdout.\n"
	  , PROGNAME, HTMLNAME, CSSNAME);
  exit(1);
}

/**
 * Drops any setuid privileges.  Called right after VC device is opened.
 */
void dropprivs() {
  int uid=getuid(), gid=getgid();
  setreuid(uid,uid);
  setregid(gid,gid);
}

/**
 * Dumps a style sheet containing virtual console attributes to the given
 * file pointer.  If attribs_used is non-null, then it must point to an array
 * of 256 chars, and only those attributes for which the corresponding char
 * is nonzero will be used.
 */
void dumpcss(FILE *fp, char *attribs_used) 
{
  char *colormap[] = { 
    "#000000", "#0000AA", "#00AA00", "#00AAAA", "#AA0000", "#AA00AA", "#AA5500", "#AAAAAA",
    "#555555", "#5555AA", "#55FF55", "#55FFFF", "#FF5555", "#FF55FF", "#FFFF00", "#FFFFFF" };
  int i;
  
  // If making full CSS, print a small header
  if (!attribs_used)
    fputs("/* Virtual console attributes automatically generated by " PROGNAME " */\n\n", fp);
  
  for (i=0; i<256; i++) {
    if (!attribs_used || attribs_used[i])
      fprintf(fp, "span.a%02x { color: %s; background-color: %s; %s}\n", 
	      i, colormap[i & 0x0F], colormap[(i>>4) & 0x07], 
	      (i & 0x80) ? "text-decoration: underline; " : "");
  }
}

/**
 * Scans the dump and marks which attributes are used.
 */
void scanattribs(VCDump *dump, char *attribs_used) {
  int n=dump->h.ys * dump->h.xs;
  CA *cap=dump->ca;
  
  while (n--)
    attribs_used[cap->attr & 255]=1, cap++;
}

/** 
 * Encodes the given VC dump, writing HTML to the given file pointer.
 */
int htmlencode(FILE *fp, VCDump *dump) {
  int y,x,oldattr=-1;
  CA * cap=dump->ca;
  
  fputs("<pre>", fp);
  for (y=0; y<dump->h.ys; y++) {
    for (x=0; x<dump->h.xs; x++) {
      int ch=cap->ch, attr=cap->attr;
      cap++;

      // if attribute changed, print appropriate tag
      if (oldattr != attr) {
	if (oldattr != -1) fputs("</span>", fp); // close old tag if open
	fprintf(fp, "<span class=\"a%02x\">", attr);
	oldattr=attr;
      }
      
      // replace unprintable characters with '?'
      if (ch & 0x7f < 0x20) ch='?'; 

      // escape some HTML entities
      switch(ch) {
      case '<': fputs("&lt;", fp); break;
      case '>': fputs("&gt;", fp); break;
      case '&': fputs("&amp;", fp); break;
	
      default: 
	fprintf(fp, "%c", ch);
      }
    }
    fputs("\n", fp);
  }
  
  fputs("</span></pre>\n", fp);
}

/** 
 * Reads a VC dump from the given file descriptor.  Returns nonzero in case
 * of I/O errors; in that case see errno.
 */
int readvc(int fd, VCDump *dump) 
{
  int y,x,r,s;
  VCHeader h;
  CA *cap;

  // read header
  if (4!=read(fd, &h, 4))
    return 1; 
  
  // allocate memory for vc data
  s = h.ys * h.xs * 2;
  if (!(cap=malloc(s))) { 
    fprintf(stderr, "Can't allocate %d bytes for VC dump buffer\n", s);
    exit(4);
  }
  
  // read vc dump
  if (s != (r=read(fd, cap, s))) {
    fprintf(stderr, "Only read %d bytes (wanted %d)\n", r, s);
    free(cap);
    return 1;
  }

  // fill in structure
  memcpy(&dump->h, &h, sizeof(dump->h));
  dump->ca=cap;
  return 0;
}

/** 
 * Prints first half of a simple HTML page to file pointer.
 */
void htmlheaders(FILE *fp, int vc, char *cssfn, char *attribs_used)
{
  fprintf(fp, 
	  "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n"
	  "<html>\n<head>\n<title>VC %d</title>\n", vc);
  if (cssfn) 
    fprintf(fp, "<link type=\"text/css\" rel=\"stylesheet\" href=\"%s\">\n", cssfn);
  else if (attribs_used) {
    // embed attributes
    fputs("<style type=\"text/css\">\n", fp);
    dumpcss(fp, attribs_used);
    fputs("</style>\n", fp);
  }
  fprintf(fp, "</head>\n<body>\n<h1>VC %d</h1>", vc);
}

void htmlfooters(FILE *fp)
{
  fputs("</body>\n</html>\n", fp);
}

/**
 * See usage() for usage information.  Should be safe for suid, if you really
 * want to give users access to all virtual consoles; use at your own risk.
 */
int main(int argc, char **argv)
{
  typedef enum { UNDEFINED, EMBED, EXT, PRE, CSS } Mode;
  Mode mode=UNDEFINED;
  char *outfn=HTMLNAME, *cssfn=CSSNAME, vcsafn[80];
  int vc=0, fd, c;
  FILE *outfp=0;
  VCDump dump;
  char *attribs_used=0;

  // parse arguments
  while ((c=getopt(argc, argv, "hepCv:o:c:?"))>0) {
    switch (c) {
    case 'h': mode=EMBED; break;
    case 'e': mode=EXT; break;
    case 'p': mode=PRE; break;
    case 'C': mode=CSS; break;

    case 'v': vc=atoi(optarg); break;
    case 'c': cssfn=optarg; break;
    case 'o': outfn=optarg; break;
      
    default: usage();
    }
  }

  // any leftover args would be erroneus; also check vc number for sanity
  if (optind<argc || mode==UNDEFINED || vc<0 || vc>255)
    usage();
  
  // figure out correct device filename
  if (vc==0) strncpy(vcsafn, VCSANAME, sizeof(vcsafn));
  else snprintf(vcsafn, sizeof(vcsafn), VCSANAME "%d", vc);
  vcsafn[sizeof(vcsafn)-1]='\0';

  // if dumping CSS only, drop privileges, dump CSS, and exit
  if (mode==CSS) {
    dropprivs();
    
    if (!strcmp(cssfn, "-"))
      outfp=stdout;
    else {
      if (!(outfp=fopen(cssfn, "wb"))) {
	perror(cssfn);
	exit(3);
      }
    }
    dumpcss(outfp,0);
    fclose(outfp);
    exit(0);
  }
  
  // otherwise, open VC device, drop privs, read VC dump, and close device
  if ((fd=open(vcsafn, O_RDONLY))<0) {
    perror(vcsafn);
    exit(2);
  }
  dropprivs();
  if (readvc(fd, &dump)) {
    perror(vcsafn);
    exit(2);
  }
  close(fd);
  
  // open output file (or point to stdout)
  if (strcmp(outfn, "-")) {
    if (!(outfp=fopen(outfn, "wb"))) {
      perror(outfn);
      exit(3);
    }
  } else outfp=stdout;
  
  // encode HTML as requested
  switch (mode) {
  case EMBED: // embed stylesheet in HTML <HEAD>
    if (!(attribs_used=calloc(256,1))) {
      fputs("Can't allocate memory for attributes used\n", stderr);
      exit(4);
    }
    scanattribs(&dump, attribs_used);
    htmlheaders(outfp, vc, 0, attribs_used);
    free(attribs_used);
    htmlencode(outfp, &dump);
    htmlfooters(outfp);
    break;
    
  case EXT: // refer to external CSS
    htmlheaders(outfp, vc, cssfn, 0);
    htmlencode(outfp, &dump);
    htmlfooters(outfp);
    break;

  case PRE: // <pre>...</pre> fragment only
    htmlencode(outfp, &dump);
    break;
  }

  // all done
  fclose(outfp);
  return 0;
}
